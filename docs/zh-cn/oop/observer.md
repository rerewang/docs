# Observer 观察者模式
观察者模式定义了一系列对象之间的一对多关系。当一个对象(subject)改变状态时，它的所有依赖者(observer)都会收到通知。

!!! [观察者模式与Reactive Programe]()

## 要点
- 观察者模式定义了对象之间的一对多关系。
- 主题(可观察者)用一个共同的接口来更新观察者。
- 可观察者和观察者之间用松耦合方式结合。可观察者不知道观察者的细节，只知道观察者实现了观察者接口。
- 使用此模式时，你可从被观察者处推(push)或拉(pull)数据(然而推的方式被认为更正确).
- 有多个观察者时，不可以依赖特定的通知顺序。
- Java中有多个观察者模式的实现，包括了通用的java.util.Observable(java9已废弃)，要注意java.util.Observable实现上带来的一些问题。
- Swing有大量的观察者模式，很多GUI框架也是如此
- 此模式也被应用在许多地方: JavaBeans/RMI
- 有必要的话，可以实现自己的Observable，这并不难。

观察者代表人物：MVC

## java.util.Observable 已废弃
### 问题
1. Observable 是一个类
Observable 是一个类，你必须设计一个类继承他。如果某类想同时具有Observable 和另一个超类的行为，就会陷入两难，毕竟java不支持多重继承。
这限制了Observable的复用潜力
2. Observable 将关键的方法保护起来

### 官方启用原因
- 他们没有为应用程序提供足够丰富的事件模型。例如，他们只能支持某些更改的概念，但不传达有关更改的任何信息。
- 不可序列化-因为，Observable不实现可序列化。因此，您既不能序列化Observable也不能对其子类进行序列化。
- 没有线程安全-方法可以被其子类覆盖，并且事件通知可以以不同的顺序发生，并且可能在不同的线程上发生，这足以破坏任何“线程安全”。
- 并且大多数问题都具有修复的复杂性，但仍然“未解决”或没有积极的发展，这就是不推荐使用的原因。

## java中观察者模式的替代方案：
对于更丰富的事件模型，请考虑使用该java.beans 程序包。
为了在线程之间进行可靠且有序的消息传递，请考虑使用java.util.concurrent程序包中的并发数据结构之一 。
有关反应式流样式的编程，请参见Flow API。


## 观察者模式是如何遵循设计原则的
- 封装变化
在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，你可以改变依赖于主题状态的的对象，却不必改变主题。这就叫提前规划。
- 针对接口编程，不针对实现编程
主题与观察者都使用接口：观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，而同时又具有松耦合的优势。
- 多用组合，少用继承
观察者模式通过’组合‘许多观察者组合进主题中。对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式产生的。