# RPC
Remote Procedure Call，即远程过程调用。
#### 作用
- 屏蔽远程调用与本地调用的区别，让我们感觉就是调用项目内的方法。
- 屏蔽地城网络通信的复杂性，让我们更专注于业务逻辑。

## RPC 通信流程
@todo

## 协议
### 协议的作用
- 类似文字中的符号，作为应用拆解请求消息的边界，保证二进制数据经过网络传输后，还能被正确地还原语义。
	- 在传输过程中，一个请求的所有二进制数据并不是整体一下子就发送到对端机器上，中间可能会拆分几个数据包，也可能合并其他请求的数据包。对于服务提供方来说，从TCP通道中收到很多二进制数据，这时候怎么识别出那些二进制是一个请求呢?

### 为什么不用 HTTP 协议?
- HTTP 无法实现请求与响应关联，每次请求都要重新建立连接，响应完成后再关闭连接，性能低
- HTTP2支持长连接，gRPC就是基于 HTTP2的，性能不好，但更容易跨语言支持。

#### RPC协议如何实现请求与响应关联呢？
- why：RPC 为了吞吐量，会异步并发发送请求，等待应答，所以需要知道哪个应答对应哪个响应
- 调用方: 请求时带上消息ID，维护消息ID列表，等待应答后与返回结果中的消息ID做匹配
- 服务方: 响应时带上请求消息的ID

### 怎么设计协议
1. 确定消息边界，所以需要先固定一个长度用来保存整个请求数据大小，所以需要协议长度:
	- 协议长度 | 协议体
2. 需要明确序列化方式（所以提出了一系列笃定长度的参数，统称为协议头）：
	- 协议头 | 协议体
		- 协议头包括: 协议长度、序列化方式、协议标识、消息ID、消息类型等
		- 协议体: 由请求接口和参数构成，长度是可变的
3. 实现可扩展的协议 *如果协议头是定长的,那么如果有新的需求，需要在协议头加入新的参数怎么办呢?*
	- 协议头固定部分 | 协议头不固定部分  | 协议体
		- 固定部分: 不固定部分的长度、上面的协议头等
		- 不固定部分: 协议头扩展字段

## 序列化
### why
- 网络传输的数据必须是二进制，所以需要将对象转换成二进制对象
- 序列化 与 反序列化

### 常用的序列化方式
核心就是设计一种序列化协议
- JDK 原生序列化
	- ObjectOutputStream 与 ObjectInputStream
	- 
- JSON
	- 额外空间开销大，需要大量的内存和磁盘开销
	- 没有类型，对于Java这种强类型语言，需要通过反射统一解决，性能不会太好
- Hessian
	- 动态类型、二进制、紧凑的，并且可跨语言移植的序列化框架
	- 字节数更小，更好的兼容性和稳定性，更适合RPC
	- 官方版本对 Java中的一些常见对象的类型不支持
		- Linked系列，LinkedHashMap、LinkedHashSet，可通过扩展CollectionDeserializer修复
		- Locale类，可通过ContextSerializerFactory修复
		- Byte/Short 反序列化时编程 Integer
- Protobuf
	- 轻便、高效的结构化数据存储格式，支持Java、Python、C++、Go等语言
	- 需要定义IDL，然后使用不同语言的IDL编译器，生成序列化工具类
	- 优点
		- 序列化后体积比JSON、Hessian小很多
		- IDL能清晰地描述语义，足以帮助并保证应用程序之间的类型不会丢失，无需类似的XML解析器
		- 反序列化速度快，不需要通过反射获取类型
		- 消息格式升级和兼容性不错，可以做到向后兼容
	- 对于具有反射和动态能力的语言来说，用起来很费劲，可以考虑使用Protostuff
	- Protostuff
		- Java版本的Protobuf，不需要依赖 IDL 文件，可以直接对 Java领域对象进行反/序列化操作
		- 不支持 bull
		- 不支持单纯的 Map、List集合对象，需要包在对象里面

#### 如何选择序列化？
安全性 > 通用性 > 兼容性 > 性能 > 效率 > 空间开销
首选：Hession 、Protobuf

### 使用时需要注意的问题
- 对象构造的过于复杂
	- 尽量高内聚
- 对象过于庞大
	- 入参和返回值体积不要太大，更不要传太大的集合
- 使用序列化框架不支持的类作为入参类
	- 使用简单的、常用的、开发语言原生的对象
- 对象有复杂的继承关系
	- 不要有父子类的情况

## 如何设计一个RPC框架
### 功能模块分层
- 核心功能体系
	- 入口层
		- 动态代理
		- 链路追踪
		- 过滤链
	- 集群层
		- 服务发现
		- 连接管理
		- 负载均衡
		- 路由
		- 容错
		- 配置管理
	- 协议层
		- 协议
		- 序列化
		- 解压缩
	- 传输层
		- TCP传输插件
		- HTTP传输插件
- 插件体系

####@rodo
- 插件化架构
- 微内核架构

### 服务发现
- 服务注册
	- 在服务提供方启动时，将对外暴露的接口注册到注册中心，注册中心将该服务节点的IP和接口保存下来。
- 服务订阅
	- 在服务调用方启动时，去注册中心查找并订阅服务提供方的IP，然后缓存到本地，并用于后续的远程调用。
- 推拉结合，以拉为准

#### 基于 ZooKeeper 的服务实现

#### 基于消息总线的最终一致型的服务实现
- 牺牲 CP ，选择 AP

### 健康检查


